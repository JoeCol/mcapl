\documentclass[a4]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{../../manual/manual}
\include{mylistings}
\makeindex

\lstset{basicstyle=\sffamily}
\author{Louise A. Dennis}

\title{AJPF Tutorial 3 -- Using AJPF to create models for other Model-Checkers}

\begin{document}
\maketitle
This is the third a series of tutorials on the use of the \ajpf\ model checking program.  This tutorial covers the use of \ajpf\ in conjunction with other model-checkers, specifically \spin\ and \prism.  \ajpf\ is used to create a model of the program which is then verified by another tool.  The main purpose of this is to enable model-checking with more expressive logics (as can be done with the \prism\ implementation), but there may also be efficiency gains in outsourcing property checking to another tool.

Files for this tutorial can be found in the \texttt{mcapl} distribution in the directory \texttt{src/examples/gwendolen/ajpf\_tutorials/tutorial3}.

This tutorial assumes familiarity with the operation of \ajpf\ as described in \ajpf\ tutorials 1 and 2 and familiarity with the theory of model-checking.  Unlike most tutorials, this tutorial is not standalone and assumes the user has access to both \spin\ and \prism.

This tutorial explains how to use the tools described in~\cite{dennis15:_two}.

\section{Separating out Model and Property}

In normal operation, the \ajpf\ system is performing two tasks at once.  Firstly it is building a \emph{model} of the program execution.  This is a graph (or Kripke Structure) of states.  These are numbered and labelled with the facts that are true in each state (e.g., ``agent 1 believes \texttt{holding\_block}'', ``agent 2 has a goal \texttt{pickup\_block}'' and so on).  At the same time it is checking this graph against a property (e.g., ``eventually agent 2 believes \texttt{holding\_block}'').  It does this by converting the property into an automaton, combining the property automaton with the Kripke structure on-the-fly (following~\cite{Gerth:1995:SOA:645837.670574,Courcoubetis92mea}) and then checking for accepting paths through this product automaton.

In this tutorial we demonstrate how \ajpf\ can be used to produce just the Kripke Structure without creating the property automaton or the product automaton.

\section{Using \ajpf\ with \spin}

\spin{}~\cite{holzmann04spin} is a popular model-checking tool
originally developed by Bell Laboratories in the 1980s.  It has been
in continuous development for over thirty years and is widely used in
both industry and academia
(e.g.,~\cite{havelund00formal,kars96application,kirsch11technical}).
\spin{} uses an input language called \promela{}.  Typically a model
of a program and the property (as a ``never claim'' --- an automaton
describing executions that violate the property) are both provided in
\promela{}, but \spin{} also provides tools to convert formulae
written in LTL into never claims for use with the
model-checker. \spin{} works by automatically generating programs
written in C which carry out the exploration of the model relative to
an LTL property. \spin{}'s use of compiled C code makes it very quick
in terms of execution time, and this is further enhanced through other
techniques such as partial order reduction. The examples in this tutorial were checked using \spin{} version 6.2.3 (24 October 2012).

To complete this tutorial you will need to download, install and run \spin.  \spin\ can be downloaded from \url{http://spinroot.com} where you can also find documentation in its use.

\subsection{Why use \spin{}}

\spin\ and \ajpf\ are both LTL model-checkers so it may seem odd to use \ajpf\ only to produce the model and then use \spin\ to create the property automaton.  There are a couple of advantages to this however.  Firstly \spin\ has more powerful tools for producing property automata and so there are some properties that \ajpf\ can not handle which \spin\ can.  Secondly \spin's LTL model checking algorithms are more efficient than \ajpf's so in theory the whole process could be quicker by using \spin.  In practice it has been demonstrated~\cite{dennis15:_two} that the major cause of slow performance in \ajpf\ is in generating the Kripke structure of the program model and any gains in efficiency from using \spin\ are often lost in converting \ajpf's program model into \promela{}.  However there may  nevertheless be situations where efficiency gains can be made.  

In terms of this tutorial, looking at the process of exporting models to \spin\ forms a useful preliminary first step before we turn our attention to \prism.

\subsection{Configuring \ajpf\ to output \spin\ models}
\label{sec:configure_spin}

In order to configure \ajpf\ to use another model checker you need to tell it:
\begin{itemize}
\item to produce \emph{only} a program model, 
\item which other model checker to target and, 
\item where to output the program model.
\end{itemize}  This is done in the \ajpf\ configuration file.  

We will use the same program that was used in \ajpf\ tutorial 2.  In the directory for tutorial 3 you will find the configuration file \texttt{TwoPickUpAgents\_Spin.jpf} that is shown below.

\noindent\rule{\textwidth}{1pt}
\begin{small}
\begin{verbatim}
@using = mcapl

target = ail.util.AJPF_w_AIL
target.args = ${mcapl}/src/examples/gwendolen/ajpf_tutorials/tutorial2/TwoPickUpAgents.ail,
${mcapl}/src/examples/gwendolen/ajpf_tutorials/tutorial3/PickUpAgent.psl,1

ajpf.model_only = true
ajpf.target_modelchecker = spin
ajpf.model.location = stdout

listener+=,.listener.ExecTracker
et.print_insn=false
et.show_shared=false
\end{verbatim}
\end{small}
\rule{\textwidth}{1pt}

This configuration file tells \ajpf\ to produce a model only (\texttt{ajpf.model\_only = true}), to target the \spin\ model checker (\texttt{ajpf.target\_modelchecker = spin}), and to print the model to standard out (\texttt{ajpf.model.location = stdout}).  If you execute it in \ajpf\ you get a print out of the model after \ajpf\  has finished executing.  This print out starts:

\noindent\rule{\textwidth}{1pt}
\begin{small}
\begin{verbatim}
bool bag1holdblock

active proctype JPFModel()
{
state0:
  bag1holdblock = true;
  if
  :: goto state1;
  :: goto state77;
  fi;
state1:
  bag1holdblock = true;
  if
  :: goto state48;
  :: goto state2;
  fi;
\end{verbatim}
\end{small}
\rule{\textwidth}{1pt}

In this, the first state (state 0) in the \ajpf\ model has become \texttt{state0} in the \promela\ model.  This state can transition to either state 1 (\texttt{state1}) or state 77 (\texttt{state77}) and so on.

This model also records one proposition \texttt{bag1holdblock} which is true in both states 0 and 1. If we look further into the model we find:

\noindent\rule{\textwidth}{1pt}
\begin{small}
\begin{verbatim}
state7:
  bag1holdblock = true;
  goto state8;
state8:
  bag1holdblock = false;
  goto state9;
state9:
  bag1holdblock = false;
  printf("end state\n");
\end{verbatim}
\end{small}
\rule{\textwidth}{1pt}
Here you can see that \texttt{bag1holdblock} is false in states 8 and 9 and that state 9 is an end state.

\paragraph{The property} The property is, in fact, the \ajpf\ property $\lbelief{ag1}{hold(block))}$ and this has been stated in the property specification language file as property 1.  

When using \ajpf\ to generate only a program model, the property it is checked against should be a conjuction of the atomic properties that will be used in the final property to be checked.  In the property specification language, the atomic properties are those about the mental state of the agent, or the perceptions in the environment, i.e., those of the form $\lbelief{ag}{f}$, $\lgoal{ag}{f}$, $\lactions{ag}{f}$, $\lintention{ag}{f}$, $\lintendtodo{ag}{f}$ and $\lpercept{ag}{f}$.

\paragraph{Printing the Output to a file} You can obviously cut and paste the \promela\ model from the \ajpf\ output into a file for use with \spin.  Alternatively you can set \texttt{ajpf.model.location} to the path to an output file.  The path should be relative to your \texttt{HOME} directory.  

If you want to give the absolute file name you need to set \texttt{ajpf.model.path} as well as \texttt{ajpf.model.location} in the configuration file.  The system will then join these to create the absolute path to the file you want to use.

The file \texttt{TwoPickUpAgents\_SpinToFile.jpf} will print the model to a file \texttt{tutorial3\_spin.pml} in the tutorial directory.

\paragraph{Model-checking the program in \spin}  In the tutorial directory you will find a file \texttt{spinprop.pml} which is a \promela\ file containing the \emph{never claim} for $\neg \eventually \lbelief{ag1}{hold(block)}$.  \spin\ searches for a contradiction, so the model-checking succeeds if it can find no path through the model where $\lbelief{ag1}{hold(block)}$ does not eventually hold.  

You can take the file containing  your program model, plus \texttt{spinprop.pml} and compile them (using \texttt{spin -a -N spinprop.pml} \emph{modelfile}) to get a C file, \texttt{pan.c}.  This needs to be compiled then executed in order to check the program.  More details on this process can be found in the \spin\ documentation.

\subsection{Exercise}

You will find a second file in the tutorial directory, \texttt{spinprop2.pml}, which contains a never claim for the property $\neg (\eventually \lbelief{ag1}{hold(block)} \wedge \eventually \neg \lbelief{ag2}{hold(block)})$.

\begin{sloppypar}
In order to verify this property you will need to adapt the property in \texttt{PickUpAgent.psl} so that it contains a  conjunction of $\lbelief{ag1}{hold(block)}$ and $\lbelief{ag2}{hold(flag)}$ and then regenerate the model and check in \spin.  As usual a solution file can be found in the answers directory.
\end{sloppypar}

\section{Using \ajpf\ with \prism}
\prism{}~\cite{KNP11} is a probabilistic symbolic model-checker in
continuous development, primarily at the Universities of Birmingham
and Oxford, since 1999. \prism{} provides broadly similar
functionality to \spin{} but also allows for the model-checking of
probabilistic models, i.e., models whose behaviour can vary depending
on probabilities represented in the model. Developers can use \prism{} to
create a probabilistic model (written in the \prism{} language) which
can then be model-checked using \prism{}'s own probabilistic property
specification language, which subsumes several well-known
probabilistic logics including PCTL, probabilistic LTL, CTL, and
PCTL*.  \prism{} has been used to formally verify a variety of systems
in which reliability and randomness play a role, including
communication protocols, cryptographic protocols and biological
systems. The examples in this tutorial were checked using \prism{} version
\texttt{4.3}.

To complete this tutorial you will need to download, install and run \prism.  \prism\ can be downloaded from \url{http://www.prismmodelchecker.org} where you can also find documentation on its use.

\subsection{Configuring \ajpf\ to output \prism\ models}

As mentioned in section~\ref{sec:configure_spin}, in order to configure \ajpf\ to use another model checker you need to tell it:
\begin{itemize}
\item to produce \emph{only} a program model, 
\item which other model checker to target and,
\item where to output the program model.  
\end{itemize}
Because \prism\ also includes probabilistic information in the model, when using \ajpf\ with \prism\ it is also important to use a \emph{listener} that records such information when a choice in the java execution is governed by a probability.

This is done in the \ajpf\ configuration file.  Initially we will, once again, use the same program that was used in \ajpf\ tutorial 2.  In the directory for tutorial 3 you will find the configuration file \texttt{TwoPickUpAgents\_Prism.jpf} that is shown below.

\newpage
\noindent\rule{\textwidth}{1pt}
\begin{small}
\begin{verbatim}
@using = mcapl

target = ail.util.AJPF_w_AIL
target.args = ${mcapl}/src/examples/gwendolen/ajpf_tutorials/tutorial2/TwoPickUpAgents.ail,${mcapl}/src/examples/gwendolen/ajpf_tutorials/tutorial3/PickUpAgent.psl,1

ajpf.model_only = true
ajpf.target_modelchecker = prism
ajpf.model.location = stdout

listener=ajpf.MCAPLProbListener

listener+=,.listener.ExecTracker
et.print_insn=false
et.show_shared=false
\end{verbatim}
\end{small}
\rule{\textwidth}{1pt}

This configuration file tells \ajpf\ to produce a model only (\texttt{ajpf.model\_only = true}), to target the \prism\ model checker (\texttt{ajpf.target\_modelchecker = prism}), to print the model to standard out (\texttt{ajpf.model.location = stdout}), and to use a probability listener (\texttt{listener=ajpf.MCAPLProbListener}).  If you execute it in \ajpf\ you get a print out of the model after \ajpf\  has finished executing.  This print out starts:

\noindent\rule{\textwidth}{1pt}
\begin{small}
\begin{verbatim}
dtmc

 module jpfModel
state : [0 ..181] init 0;
bag1holdblock: bool init true;
[] state = 0 -> 0.5:(state'=1) & (bag1holdblock'= true) + 0.5:(state'=77) & (bag1holdblock'= true);
[] state = 1 -> 0.5:(state'=48) & (bag1holdblock'= true) + 0.5:(state'=2) & (bag1holdblock'= true);
[] state = 2 -> 0.5:(state'=3) & (bag1holdblock'= true) + 0.5:(state'=29) & (bag1holdblock'= true);
[] state = 3 -> 0.5:(state'=17) & (bag1holdblock'= true) + 0.5:(state'=4) & (bag1holdblock'= true);
[] state = 4 -> 0.5:(state'=5) & (bag1holdblock'= true) + 0.5:(state'=12) & (bag1holdblock'= true);
\end{verbatim}
\end{small}
\rule{\textwidth}{1pt}

There is no specificially probabilistic behaviour in this example, however there are two agents and the system, by default, assumes each again has an equal chance of running every time the scheduler makes a decision.  We can see here, therefore, that in state 0 there is a 50\% change that the system will transition to state 1 and a 50\% chance that it will transition to state 77.  As with the \spin\ example we are interested in one property, \texttt{bag1holdblock} ($\lbelief{ag1}{hold(block))}$) and this is true in all the initial states of the mode.

\paragraph{The property} Just as when using \ajpf\ with \spin, the property in the \ajpf\ property specification file should be a conjuction of the atomic properties that will be used in the final property to be checked.  In the property specification language, the atomic properties are those about the mental state of the agent, or the perceptions in the environment, i.e., those of the form $\lbelief{ag}{f}$, $\lgoal{ag}{f}$, $\lactions{ag}{f}$, $\lintention{ag}{f}$, $\lintendtodo{ag}{f}$ and $\lpercept{ag}{f}$.

\paragraph{Printing the Output to a file} You can obviously cut and paste the \prism\ model from the \ajpf\ output into a file for use with \prism.  Alternatively you can set \texttt{ajpf.model.location} to the path to an output file.  The path should be relative to your \texttt{HOME} directory.  

If you want to give the absolute file name you need to set \texttt{ajpf.model.path} as well as \texttt{ajpf.model.location} in the configuration file.  The system will then join these to create the absolute path to the file you want to use.

The file \texttt{TwoPickUpAgents\_PrismToFile.jpf} will print the model to a file \texttt{tutorial3\_prism.pm} in the tutorial directory.

\paragraph{Model-checking the program in \prism}.  In the tutorial directory you will find a file \texttt{prismprop1.pctl} which is a \prism\ file containing the PCTL property for $P^{=?}\always \eventually \lbelief{ag1}{hold(block)}$.  

You can take the file containing  your program model, plus \texttt{prismprop1.pctl} and run them in \prism\ (using \texttt{prism} \emph{model file} \texttt{prismprop1.pctl}).  This property is actually false and you should get a result of 0 probability:

\texttt{Result: 0.0 (value in the initial state)}.

More details on this process can be found in the \spin\ documentation.

\section{Model-Checking Agent Sytems with Probabilistic Behaviour}

We will now look at a program with probabilistic behaviour.  This program a modified version of one used in \ail\ tutorial 3. The program consists of a robot, \texttt{searcher.gwen}, which searches a 3x3 grid in order to find a human and an environment, \texttt{RandomRobotEnv}, in which a human is moving between the squares and could be at (0, 1), (1, 1) or (2, 1) with a 50\% chance of being at (1, 1), a 30\% chance of being at (2, 1) and a 20\% chance of being at (0, 1).  The robot only finds the human if it is in the same square as the robot and it immediately leaves the area once it finds the human (if it has checked every square without finding the human then it checks every square again) therefore there is a chance that the robot will never check the last square (2, 2).

In the directory for tutorial 3 you will find the \ajpf\ configuration file \texttt{searcher.jpf} for this program, that is shown below.

\noindent\rule{\textwidth}{1pt}
\begin{small}
\begin{verbatim}
@using = mcapl

target = ail.util.AJPF_w_AIL
target.args = ${mcapl}/src/examples/gwendolen/ajpf_tutorials/tutorial3/searcher.ail,${mcapl}/src/examples/gwendolen/ajpf_tutorials/tutorial3/searcher.psl,1

log.info = ail.mas.DefaultEnvironment,ajpf.product.Product

ajpf.model.location = stdout
ajpf.model_only = true
ajpf.target_modelchecker = prism

listener=ajpf.MCAPLProbListener

listener+=,.listener.ExecTracker
et.print_insn=false
et.show_shared=false
\end{verbatim}
\end{small}
\noindent\rule{\textwidth}{1pt}

This file target's the \prism\ model checker and prints the model to standard out.  It uses the listener \texttt{ajpf.MCAPLProbListener} to record probabilistic information as the model his built.  If you execute it in \ajpf\ you get a print out of the model after \ajpf\  has finished executing.  This print out starts

\noindent\rule{\textwidth}{1pt}
\begin{small}
\begin{verbatim}
dtmc

 module jpfModel
state : [0 ..156] init 0;
bsearcherempty2020: bool init false;
[] state = 0 -> 1.0:(state'=1) & (bsearcherempty2020'= false);
[] state = 1 -> 0.5:(state'=2) & (bsearcherempty2020'= false) + 0.3:(state'=146) & (bsearcherempty2020'= false) + 0.2:(state'=148) & (bsearcherempty2020'= false);
[] state = 2 -> 1.0:(state'=3) & (bsearcherempty2020'= false);
[] state = 3 -> 0.2:(state'=144) & (bsearcherempty2020'= false) + 0.5:(state'=4) & (bsearcherempty2020'= false) + 0.3:(state'=142) & (bsearcherempty2020'= false);
[] state = 4 -> 1.0:(state'=5) & (bsearcherempty2020'= false);
[] state = 5 -> 0.5:(state'=6) & (bsearcherempty2020'= false) + 0.3:(state'=138) & (bsearcherempty2020'= false) + 0.2:(state'=140) & (bsearcherempty2020'= false);
[] state = 6 -> 1.0:(state'=7) & (bsearcherempty2020'= false);
[] state = 7 -> 0.3:(state'=134) & (bsearcherempty2020'= false) + 0.5:(state'=8) & (bsearcherempty2020'= false) + 0.2:(state'=136) & (bsearcherempty2020'= false);
[] state = 8 -> 1.0:(state'=9) & (bsearcherempty2020'= false);
[] state = 9 -> 0.2:(state'=132) & (bsearcherempty2020'= false) + 0.5:(state'=10) & (bsearcherempty2020'= false) + 0.3:(state'=13) & (bsearcherempty2020'= false);
[] state = 10 -> 1.0:(state'=11) & (bsearcherempty2020'= false);
[] state = 11 -> 1.0:(state'=156) & (bsearcherempty2020'= false);
[] state = 13 -> 1.0:(state'=14) & (bsearcherempty2020'= false);
\end{verbatim}
\end{small}
\noindent\rule{\textwidth}{1pt}

In this state 0 can only state 1.  State 1 can transition to three states representing the movement of the human: state 2 (probability 0.5), state 146 (with probability 0.3) and state 148 (with probability 0.2) and so on.

This model also records one proposition \texttt{bsearcherempty2020} which is false in both states 1 and 2 but if you look further into the model you will see it becomes true when state 21 transitions to state 22.

\paragraph{The property} The property is the \ajpf\ property $\lbelief{searcher}{empty(2, 2)}$ and this has been stated in the property specification language file as property 1. 

\paragraph{Model-checking the program in \prism}  In the tutorial directory you will find a file \texttt{prismprop2.pctl} which is a \prism\ file containing the PCTL property for $P^{=?}\eventually \lbelief{searcher}{empty(2, 2)}$.  If you run your \prism\ model with this file you should find that the property has a 35\% chance of being true -- i.e., the robot has a 35\% chance of checking the final square.

In the property specification file there is a second property for $\lbelief{searcher}{found}$ (that the searcher has found the human).  If you generate a model for this property and check it in \prism\ you will find its probabily is 1, even though there is an infinite loop where the robot never finds the human, it is just that the probabilty that the robot will remain in this infinite loop forever is infinitesimally small.

\subsection{A Note on Creating Environments with Probabilistic Behaviour}

In order for \ajpf's probability listener to work correctly, all randomness (and probabilistic behaviour) should be created using \ail's \texttt{Choice} classes as documented in \ail\ tutorial 3.

It is important that probabilistic choices cause \emph{unique} transitions in the model.  If, for instance, you generate four choices each with, say, a 25\% probability but two of them end up leading to the same next state then AJPF will only annotate the transition with one of the probabilities (not the sum of both) and this will lead to \prism\ throwing an error.  For instance say you have for choices each representing a direction some human could move in, north, east, south or west, but if that direction were to take the human off the grid then you have the human remain in the same place instead, then when the human is in the corner of the grid two of those choices will lead to the same result (the human remains in place).

\subsection{Exercise}

You will find, in the tutorial directory an \ail\ program, \texttt{pickuprubble.ail}.  This controls a robot (called, \texttt{robot}) that searches a small 2x3 grid for injured humans.  There is one human in the grid who moves around it randomly and one building in the grid that may collapse.  If the building collapses onto the human then they will be injured.  The robot systematically searches the grid.  If it encounters the human it will direct them to safely and if it finds them injured it will assist them.  However the once the robot has reached the top corner of the grid it will stop searching so there is a chance that it will have missed the human and that the human will have been caught in a collapsing building.

Create an \ajpf\ configuration file and property specification file that will generate a prism model.  In the tutorial directory you will find a file \texttt{prismprop\_ex.pctl} which tests to see whether if there injured humans are perceptible on the grid $\lpercept{injured\_humans}$ the robot eventually assists them $\lactions{robot}{assist_humans}$.  You should be able to discover that there is an 88\% chance of the robot assisting any injured human.  Note that the \ajpf\ model build will take several minutes to run (it generates 3,546 states).

As usual solution files can be found in the answers directory.
\bibliographystyle{abbrv} %% {plain}
\bibliography{../../manual/manual}


\end{document}
