// ----------------------------------------------------------------------------
// Copyright (C) 2013 Louise A. Dennis, and  Michael Fisher 
//
// This file is part of GOAL (AIL version) - GOAL-AIL
// 
// GOAL-AIL is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 3 of the License, or (at your option) any later version.
// 
// GOAL-AIL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with GOAL-AIL; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
// 
// To contact the authors:
// http://www.csc.liv.ac.uk/~lad
//
//----------------------------------------------------------------------------

// Code taken from an example in Programming Rational Agents in GOAL by Koen Hindriks
main: stackBuilder
{
	init module {
   		knowledge{
      	% only blocks can be on top of another object.
      	block(X) :- on(X, _).
      	% a block is clear if nothing is on top of it.
      	clear(X) :- block(X), not( on(_, X) ), not(holding(X)).
      	% the table is always clear.
      	clear(table).
      	above(X, Y) :- on(X, Y).
      	above(X, Y) :- on(X, Z), above(Z, Y).
      	% the tower predicate holds for any stack of blocks that sits on the table.
      	tower([X]) :- on(X, table).
      	tower([X, Y| T]) :- on(X, Y), tower([Y | T]). 
    	}
   
  		beliefs{
      		on(a,table). on(b,c). on(c,table). on(d,e). on(e,f). on(f,table).
   		}
   
   		goals{
      		on(a,table), on(b,a), on(c,b), on(d,c), on(e,table), on(f,e).
   		}
   		
   		actionspec{
   			pickup(X) {
   				pre{ clear(X), on(X, Y), not(holding(Z)) }
   				post{ holding(X), not(on(X, Y)) }
   			}
   			putdown(X, Y) {
   				pre{ clear(Y), holding(X) }
   				post{ not(holding(X)), on(X, Y) }
   			}
   		}
   	}
   
   main module{
      program{
      	% pick up a block that needs moving
      	if a-goal(tower[X|T])), bel(above(Z,X);Z=X)) then pickup(Z).
      	% constructive move
      	if a-goal(tower[X, Y|T])), bel(tower([Y|T])) then putdown(X, Y).
      	% put block on table
      	if bel(holding(X)) then putdown(X, table).
      }
   }
}
 