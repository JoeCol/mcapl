// ----------------------------------------------------------------------------
// Copyright (C) 2013 Louise A. Dennis, and  Michael Fisher 
//
// This file is part of GOAL (AIL version) - GOAL-AIL
// 
// GOAL-AIL is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 3 of the License, or (at your option) any later version.
// 
// GOAL-AIL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with GOAL-AIL; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
// 
// To contact the authors:
// http://www.csc.liv.ac.uk/~lad
//
//----------------------------------------------------------------------------

// Code taken from an example in Programming Rational Agents in GOAL by Koen Hindriks
main: stackBuilder
{
   knowledge{
      % only blocks can be on top of another object.
      block(X) :- on(X, _).
      % a block is clear if nothing is on top of it.
      clear(X) :- block(X), not( on(_, X) ).
      % the table is always clear.
      clear(table).
      % the tower predicate holds for any stack of blocks that sits on the table.
      tower([X]) :- on(X, table).
      tower([X, Y| T]) :- on(X, Y), tower([Y | T]). 
    }
   
   beliefs{
      on(a,b). on(b,c). on(c,table). on(d,e). on(e,table). on(f,g). on(g,table).
   }
   
   goals{
      on(a,e), on(b,table), on(c,table), on(d,c), on(e,b), on(f,d), on(g,table).
   }
   
   main module{
      program[order=random]{
         #define constructiveMove(X,Y) a-goal(tower([X,Y| T])), bel(tower([Y|T])).
         #define misplaced(X) a-goal(tower([X| T])).
         
         if constructiveMove(X, Y) then move(X, Y).
         if misplaced(X) then move(X, table).
       }
   }
   
   actionspec{
      move(X,Y) {
         pre{ clear(X), clear(Y), on(X, Z), not(X=Y)}
         post{ not(on(X,Z)), on(X, Y) }
      }
   }
}
 