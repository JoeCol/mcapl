// ----------------------------------------------------------------------------
// Copyright (C) 2012 Louise A. Dennis, and  Michael Fisher 
//
// This file is part of GOAL (AIL version) - GOAL-AIL
// 
// GOAL-AIL is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 3 of the License, or (at your option) any later version.
// 
// GOAL-AIL is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with GOAL-AIL; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
// 
// To contact the authors:
// http://www.csc.liv.ac.uk/~lad
//
//----------------------------------------------------------------------------

GOAL 

:name: ag1 

:beliefs 
hold(fork, right) 
neighbour(ag2, right) 
neighbour(ag3, left) 
hungry 

:Belief Rules: 

neighbours(X, Y) :- neighbour(X, left), neighbour(Y, right) 
forkAvailable(D)  :- hold(fork, D); on(fork, table, D) 
forksAvailable :- forkAvailable(left), forkAvailable(right) 

:goals 

:Conditional Actions: 
if B hungry then eat
if B hungry then adopt(hold(fork,left) & hold(fork, right)) 
if G hold(fork, Hand),  ~ B forksAvailable, B neighbours(X, Y) then send(new:[X Y], !hold(fork)) 
if B neighbour(K, D), ~ B hold(fork, D), ~ B _K hold(fork), B _K on(fork,table), ~ B on(fork, table, D) then ins(on(fork, table, D)) 
if B conversation(Id, :me), B neighbour(X, D), ~ B hold(fork, D), B on(fork, table, D) then pickUp(fork, D), send(Id:[X], .hold(fork)) 
if B conversation(Id, :me), B neighbour(X, D), B hold(fork, D), B on(fork, table, D) then del(on(fork, table, D)), send(Id:[X], .hold(fork)) 
if B conversation(Id, :me), B hold(fork, left), B hold(fork, right), B neighbours(K, Y), ~ B _K on(fork, table), ~ B _Y on(fork, table) then close(Id) 
if B conversation(Id, K), B neighbour(K, D), G _K hold(fork) then putDown(fork, D), send(Id: [K], .on(fork, table), .~hold(fork)) 
if B conversation(Id, K), B neighbour(K, D), B _K hold(fork) then del(on(fork, table, D)), send(Id:[K], ?on(fork, table)) 

:Action Specifications: 
think { ~ B hungry} {hungry} 
pickUp(fork, D) {B on(fork, table, D)} {hold(fork, D), ~on(fork, table, D)} 
eat {B hungry, B hold(fork, left), B hold(fork, right)} {~hungry} 
putDown(fork, D) {B hold(fork, D)} {on(fork, table, D), ~hold(fork, D)} 

:name: ag2 

:beliefs 
neighbour(ag3, right) 
neighbour(ag1, left) 
hold(fork, right) 
hungry 

:Belief Rules: 

neighbours(X, Y) :- neighbour(X, left), neighbour(Y, right) 
forkAvailable(D)  :- hold(fork, D); on(fork, table, D) 
forksAvailable :- forkAvailable(left), forkAvailable(right) 

:goals 

:Conditional Actions: 
if B hungry then eat
if B hungry then adopt(hold(fork,left) & hold(fork, right)) 
if G hold(fork, Hand),  ~ B forksAvailable, B neighbours(X, Y) then send(new:[X Y], !hold(fork)) 
if B neighbour(K, D), ~ B hold(fork, D), ~ B _K hold(fork), B _K on(fork,table), ~ B on(fork, table, D) then ins(on(fork, table, D)) 
if B conversation(Id, :me), B neighbour(X, D), ~ B hold(fork, D), B on(fork, table, D) then pickUp(fork, D), send(Id:[X], .hold(fork)) 
if B conversation(Id, :me), B neighbour(X, D), B hold(fork, D), B on(fork, table, D) then del(on(fork, table, D)), send(Id:[X], .hold(fork)) 
if B conversation(Id, :me), B hold(fork, left), B hold(fork, right), B neighbours(K, Y), ~ B _K on(fork, table), ~ B _Y on(fork, table) then close(Id) 
if B conversation(Id, K), B neighbour(K, D), G _K hold(fork) then putDown(fork, D), send(Id: [K], .on(fork, table), .~hold(fork)) 
if B conversation(Id, K), B neighbour(K, D), B _K hold(fork) then del(on(fork, table, D)), send(Id:[K], ?on(fork, table)) 

:Action Specifications: 
think { ~ B hungry} {hungry} 
pickUp(fork, D) {B on(fork, table, D)} {hold(fork, D), ~on(fork, table, D)} 
eat {B hungry, B hold(fork, left), B hold(fork, right)} {~hungry} 
putDown(fork, D) {B hold(fork, D)} {on(fork, table, D), ~hold(fork, D)} 

:name: ag3 

:beliefs 
hold(fork, right) 
neighbour(ag1, right) 
neighbour(ag2, left) 
hungry 

:Belief Rules: 

neighbours(X, Y) :- neighbour(X, left), neighbour(Y, right) 
forkAvailable(D)  :- hold(fork, D); on(fork, table, D) 
forksAvailable :- forkAvailable(left), forkAvailable(right) 

:goals 

:Conditional Actions: 
if B hungry then eat
if B hungry then adopt(hold(fork,left) & hold(fork, right)) 
if G hold(fork, Hand),  ~ B forksAvailable, B neighbours(X, Y) then send(new:[X Y], !hold(fork)) 
if B neighbour(K, D), ~ B hold(fork, D), ~ B _K hold(fork), B _K on(fork,table), ~ B on(fork, table, D) then ins(on(fork, table, D)) 
if B conversation(Id, :me), B neighbour(X, D), ~ B hold(fork, D), B on(fork, table, D) then pickUp(fork, D), send(Id:[X], .hold(fork)) 
if B conversation(Id, :me), B neighbour(X, D), B hold(fork, D), B on(fork, table, D) then del(on(fork, table, D)), send(Id:[X], .hold(fork)) 
if B conversation(Id, :me), B hold(fork, left), B hold(fork, right), B neighbours(K, Y), ~ B _K on(fork, table), ~ B _Y on(fork, table) then close(Id) 
if B conversation(Id, K), B neighbour(K, D), G _K hold(fork) then putDown(fork, D), send(Id: [K], .on(fork, table), .~hold(fork)) 
if B conversation(Id, K), B neighbour(K, D), B _K hold(fork) then del(on(fork, table, D)), send(Id:[K], ?on(fork, table)) 

:Action Specifications: 
think { ~ B hungry} {hungry} 
pickUp(fork, D) {B on(fork, table, D)} {hold(fork, D), ~on(fork, table, D)} 
eat {B hungry, B hold(fork, left), B hold(fork, right)} {~hungry} 
putDown(fork, D) {B hold(fork, D)} {on(fork, table, D), ~hold(fork, D)}