GWENDOLEN

:name: cleaner

:Initial Beliefs:
//Possible Tasks task(name, [goals/actions], [statesOfTheWorld])
task(cleanroomA, [cleanroomA], [])
task(cleanroomB, [cleanroomB], [])
task(cleanroomC, [cleanroomC], [])
task(cleanroomD, [cleanroomD], [])
task(cleanroomE, [cleanroomE], [])
task(cleanroomF, [cleanroomF], [])
task(cleanroomG, [cleanroomG], [])
task(cleanroomH, [cleanroomH], [])
task(cleanroomI, [cleanroomI], [])
task(cleanroomJ, [cleanroomJ], [])

task(sendStatus, [sendStatus], [])
 
//Possible Responsibilities res(name, [subres], task, [failres], {oneshot,repeat})
res(report, [], sendStatus, [], repeat)

res(cleanA, [], cleanroomA, [], oneshot)
res(cleanB, [], cleanroomB, [], oneshot)
res(cleanC, [], cleanroomC, [], oneshot)
res(cleanD, [], cleanroomD, [], oneshot)
res(cleanE, [], cleanroomE, [], oneshot)
res(cleanF, [], cleanroomF, [], oneshot)
res(cleanG, [], cleanroomG, [], oneshot)
res(cleanH, [], cleanroomH, [], oneshot)
res(cleanI, [], cleanroomI, [], oneshot)
res(cleanJ, [], cleanroomJ, [], oneshot)

res(cleanBadDirtA, [], cleanroomA, [], oneshot)
res(cleanBadDirtB, [], cleanroomB, [], oneshot)
res(cleanBadDirtC, [], cleanroomC, [], oneshot)
res(cleanBadDirtD, [], cleanroomD, [], oneshot)
res(cleanBadDirtE, [], cleanroomE, [], oneshot)
res(cleanBadDirtF, [], cleanroomF, [], oneshot)
res(cleanBadDirtG, [], cleanroomG, [], oneshot)
res(cleanBadDirtH, [], cleanroomH, [], oneshot)
res(cleanBadDirtI, [], cleanroomI, [], oneshot)
res(cleanBadDirtJ, [], cleanroomJ, [], oneshot)

//care values
care(cleanA,1)
care(cleanBadDirtA,10)
care(cleanB,1)
care(cleanBadDirtB,10)
care(cleanC,1)
care(cleanBadDirtC,10)
care(cleanD,1)
care(cleanBadDirtD,10)
care(cleanE,1)
care(cleanBadDirtE,10)
care(cleanF,1)
care(cleanBadDirtF,10)
care(cleanG,1)
care(cleanBadDirtG,10)
care(cleanH,1)
care(cleanBadDirtH,10)
care(cleanI,1)
care(cleanBadDirtI,10)
care(cleanJ,1)
care(cleanBadDirtJ,10)

care(report,0)

//Capacity - In essence pre-computed
capacity(cleanA)
capacity(cleanBadDirtA)
capacity(cleanB)
capacity(cleanBadDirtB)
capacity(cleanC)
capacity(cleanBadDirtC)
capacity(cleanD)
capacity(cleanBadDirtD)
capacity(cleanE)
capacity(cleanBadDirtE)
capacity(cleanF)
capacity(cleanBadDirtF)
capacity(cleanG)
capacity(cleanBadDirtG)
capacity(cleanH)
capacity(cleanBadDirtH)
capacity(cleanI)
capacity(cleanBadDirtI)
capacity(cleanJ)
capacity(cleanBadDirtJ)

capacity(report)


//Current Responsibilities
responsibilities([])
finished([]) //completed tasks
failed([])

//Process Loops
acceptedStage(newres)
actionStage(start)

:Reasoning Rules:
allTasks([],[]);
allTasks([H|T], [Tasks|OtherTasks]) :- res(H, _, Name, _, _), task(Name,[Tasks],_), allTasks(T,OtherTasks);

resIn(Res,[],false);
resIn(H,[H],true);
resIn(H,[H|T],true);
resIn(H,[H1|T],Out) :- resInFin(H,T,Out);
:Initial Goals:
preRes[achieve]
//test(1)[perform]

:Plans:
//Test getting tasks
//+!test[perform] : {B allTasks([report,cleanA,cleanB,cleanBadDirtC,cleanBadDirtA],Out)} <- prt(Out);

//+!test(1)[perform] : {B resInFin(cleanA,[report,cleanA],true)} <- prt("Works for last item"), +!test(2)[perform];
//+!test(2)[perform] : {B resInFin(cleanB,[report,cleanA],false)} <- prt("Works for false"), +!test(3)[perform];
//+!test(3)[perform] : {B resInFin(cleanB,[report,cleanA],A)} <- prt("Result ", A), +!test(4)[perform];
//+!test(4)[perform] : {B resInFin(cleanA,[report,cleanA],A)} <- prt("Result ", A);

//Check that responsibilities are done
+!checkFinishedResponsibilities([])[perform] : {True} <- prt("All finished checked");
+!checkFinishedResponsibilites([Res|T])[perform] : {B finished(Fin), B resInFin(Res,Fin,true), B res(Res,_,_,_,oneshot)} <- prt("Res Done"), +!remList(Res)[perform], +!checkFinishedResponsibilites(T)[perform]; 
+!checkFinishedResponsibilites([Res|T])[perform] : {B finished(Fin), B resInFin(Res,Fin,true), B res(Res,_,_,_,repeat)} <- prt("Res Done"), +!remList(Res)[perform], resentRes(Res), +!checkFinishedResponsibilites(T)[perform]; 
+!checkFinishedResponsibilites([Res|T])[perform] : {B failed(Fin), B resInFin(Res,Fin,true)} <- prt("Res failed"), +!remList(Res)[perform], +!checkFinishedResponsibilites(T)[perform]; 
+!checkFinishedResponsibilites([Res|T])[perform] : {True} <- prt("Res not done"), +!checkFinishedResponsibilites(T)[perform]; 


+!do([H|T])[perform] : {B actionReady} <- +!action(H)[perform], +!do([T])[perform];
+!do([H|T])[perform] : {~B actionReady} <- prt("Interrupted");

//Do responsibility
+!doRes([])[perform] : {True} <- prt("done all res"), +.lock, +!checkFinishedResponsibilities(Res)[perform], -.lock;
+!doRes([H|T])[perform] : {B actionReady, B res(H,_,TName,_,_), B task(TName,[Task],[State])} <- +!do([Task|State])[perform];
+!doRes([H|T])[perform] : {~B actionReady} <- prt("Interrupted");

//Prepare task list
+!preRes[achieve] : {~B actionReady} <- *actionReady;
+!preRes[achieve] : {B actionReady, B responsibilities([])} <- -actionReady;
+!preRes[achieve] : {B actionReady, B responsibilities(Res)} <- getCombos(Res,Combo), getViable(Combo,Viable), selectCared(Viable,Out), +!doRes(Out)[perform];

//Manage lists
+!addRes(Res)[perform] : {B responsibilities(L)} <- +.lock, -responsibilities(L), addResItem(Res,L,Out), +responsibilities(Out), -.lock;
+!remRes(Res)[perform] : {B responsibilities(L)} <- +.lock, -responsibilities(L), deleteItem(Res,L,Out), +responsibilities(Out), -.lock;

//Add new responsibility
+!incomingRes(Assignee,[Res])[perform] : {B capacity(Res)} <- -actionReady, +.lock, +!addRes(Res)[perform], +!reportOutcome(yes,Assignee,Res)[perform], -.lock, +actionReady;
+!incomingRes(Assignee,[Res])[perform] : {~B capacity(Res)} <- +!reportOutcome(no,Assignee,Res)[perform];

//Messages to send back
+!reportOutcome(_, [], Res)[perform] : {True} <- prt("Reported accepted to all");
+!reportOutcome(yes, [Assignee|T], Res)[perform] : {True} <- prt("Reporting acceptance to ", Assignee), .send(Assignee, :tell, accepted(Res, cleaner)), +!reportOutcome(yes,T,Res)[perform];
+!reportOutcome(yes, Assignee, Res)[perform] : {True} <- prt("Reporting acceptance to ", Res, " to ", Assignee), .send(Assignee, :tell, accepted(Res, cleaner));
+!reportOutcome(no, [Assignee|T], Res)[perform] : {True} <- prt("Reporting rejection to ", Assignee), .send(Assignee, :tell, rejected(Res, cleaner)), +!reportOutcome(yes,T,Res)[perform];
+!reportOutcome(no, Assignee, Res)[perform] : {True} <- prt("Reporting rejection to ", Res, " to ", Assignee), .send(Assignee, :tell, rejected(Res, cleaner));

//Received a delegated responsibility Example: assignment([ag1,ag2],safety)
+.received(:tell, assignment(Assignee,Res)) : {True} <- prt("Received Assignment"), +!incomingRes(Assignee,[Res])[perform];
+.received(:tell, accepted(Res,Assignee)) : {True} <- prt("Received ", accepted(Res,Assignee)), -waiting(Res,Assignee), +delegated(Res,Assignee);
+.received(:tell, finished(sendStatus)) : {True} <- +!addList(don,sendStatus)[perform];
+.received(:tell, finished(Task)) : {True} <- -busy, +!addList(don,Task)[perform];
+.received(:tell, X) : {True} <- print(X), printstate, break;

//Specific Actions & states
+!action(Res,sendStatus)[perform] : {True} <- prt("Send Report to Manager"), sendReport(Manager), addToFinished(Res);
+!action(Res,cleanroomF)[perform] : {True} <- clearActions, goToZone("F"), clean("F"), addToFinished(Res);
+!action(Res,AnyAction)[perform] : {B busy} <- prt("currently working on ");
+!action(Res,AnyAction)[perform] : {True} <- prt("Action ", anyAction, " not recognised for Res ", Res);

