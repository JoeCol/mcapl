GWENDOLEN

:name: manager

:Initial Beliefs:
//Possible Tasks task(name, [goals/actions], [statesOfTheWorld])
task(report, [reportToHuman], [])
task(safety, [], [isSafe])
task(clean, [clean1,clean2,clean3,clean4,clean5], [])
task(observer, [observe1,observe2,observe3,observe4,observe5], [allRoomsWillBeObserved])
 
//Possible Responsibilities res(name, [subres], task, [failres], {oneshot,repeat})
res(report, [], report, [], oneshot)
res(safety, [clean, observe], safety, [report], repeat)
res(clean, [], clean, [], repeat)
res(observe, [], observer, [], repeat) 

//care values
care(clean,2)
care(safety,4)
care(observe,1)
care(report,10)

//Capacity - In essence pre-computed
capacity(reportToHuman)
capacity(safety)
capacity(isSafe)
capacity(clean)
capacity(observe)

//Working on task/res order
doAll
//doOne
//doRandomOne
cleanup(no)

//Current Responsibilities
currentRes([])
//Current Working Task
workingActions([])
workingStates([])
workingRes([])

//Assumptions for testing
process(none,start)//where in process loop
:Reasoning Rules:


:Initial Goals:
test[perform]

:Plans: 
//New Version
+!processSuccess[perform] : {True} <- prt("Process Success");

+!processFailure[perform] : {True} <- prt("Process Failure");

+!checkSubRes([])[perform] : {True} <- processSuccess;
+!checkSubRes([SubRes|T])[perform] : {~B failed(SubRes)} <- +!checkSubRes([T])[perform];
+!checkSubRes([SubRes|T])[perform] : {B failed(SubRes)} <- +failed(Res), processFailure;

+!checkSuccess(Res)[perform] : {B failed} <- processFailure;
+!checkSuccess(Res)[perform] : {B finished} <- checkSubRes(SubRes);

//Work on One State
+!checkSDone(State,true)[perform] : {B completedStates(DoneStates)} <- -completedStates(DoneStates), appendList([State],DoneStates,Out), +completedStates(Out), +!processLoop[perform];
+!checkSDone(State,false)[perform] : {True} <- -actionState(State), processLoop()[perform];
+!workOnStates(Task)[perform] : {B actionState(none)} <- -actionState(none,_), -process(Res,A), +process(Res,states), +!processLoop[perform];
+!workOnStates(Task)[perform] : {B actionState(State)} <- do(State,Done), -actionState(State), +!checkSDone(State,Done);
+!workOnStates(Task)[perform] : {B task(Task,States,_), B completedStates(DoneStates)} <- getNextInList(States,DoneStates,State), +actionState(State), +!workOnStates(Task)[perform];

//Work on one action
+!checkADone(Action,true)[perform] : {B completedActions(DoneActions)} <- -completedActions(DoneActions), appendList([Action],DoneActions,Out), +completedActions(Out), +!processLoop[perform];
+!checkADone(Action,false)[perform] : {True} <- processLoop()[perform];
+!workOnActions(Task)[perform] : {B actionState(none)} <- -actionState(none,_), -process(Res,A), +process(Res,states), +!processLoop[perform];
+!workOnActions(Task)[perform] : {B actionState(Action)} <- do(Action,Done), -actionState(Action), +!checkADone(Action,Done);
+!workOnActions(Task)[perform] : {B task(Task,Actions,_), B completedActions(DoneActions)} <- getNextInList(Actions,DoneActions,Action), +actionState(Action), +!workOnActions(Task)[perform];

//New responsibility has been added
+!processLoop[perform] : {~B ready} <- prt("Waiting for decision on incoming"), *ready, prt("Started processing again"), +!processLoop[perform];
//New responsibility added, reset to check if new responsibility is higher priority
+!processLoop[perform] : {B newRes, B process(A,B)} <- -process(A,B), +process(none,start), -newRes; 
//Get the most cared about responsibility
+!processLoop[perform] : {B process(none,start), B currentRes(ResList)} <- getCared(ResList,Res), -process(none,start), +process(Res,actions), +!processLoop[perform];
//Do an action from the Task associated with the Responsibility 
+!processLoop[perform] : {B process(Res,actions), B res(Res,_,Task,_,_)} <- workOnActions(Task);
+!processLoop[perform] : {B process(Res,states)} <- workOnStates(Res);
+!processLoop[perform] : {B process(Res,check)} <- checkSuccess(Res);
+!processLoop[perform] : {B process(Res,subRes)} <- processSubRes(Res);
+!processLoop[perform] : {B process(Res,failure)} <- processFailure(Res);
+!processLoop[perform] : {B process(Res,success)} <- processSuccess(Res);

//Received a delegated responsibility Example: assignment([ag1,ag2],safety)
+.received(:tell, assignment(Assignee,Res)): {True} <- -ready, +.lock, print("Received Assignment"), +!incomingRes(Assignee,[Res])[perform], -.lock, +ready;
+.received(:tell, X) : {True} <- print(X);

//Delegate
+!delegate(X,Ags)[perform] : {True} <- .send(Ags,:tell,X);

//Report back
+!reportBack(Res)[perform] : {B finished(Res), B assignment(Assignee,Res,manager)} <- .send(Assignee, :tell, finished(Res));
+!reportBack(Res)[perform] : {B failed(Res), B assignment(Assignee,Res,manager)} <- .send(Assignee, :tell, failed(Res));
+!reportBack(Res)[perform] : {True} <- prt("Reporting back unfinished responsibility ", Res);

//Current Responsibility List Management
+!add(X)[perform] : {B currentRes(Z)} <- +.lock, -currentRes(Z), appendList(X,Z,Y), +currentRes(Y), -.lock;
+!rem(X)[perform] : {B currentRes(Z)} <- +.lock, -currentRes(Z), removeList(X,Z,Y), +currentRes(Y), -.lock;

//Tell assignee of acceptance
+!informAssignment([], Res)[perform] : {True} <- print("Informed all assignees");
+!informAssignment([Assignee|T], Res)[perform] : {True} <- prt("Informing acceptance to ", Assignee), .send(Assignee, :tell, accepted(Res, manager)), +!informAssignment(T,Res)[perform];

//Add Accepted Responsibility to list
+!addAcceptedRes(Assignee, NewRes)[perform] : {B currentRes(Res), B res(NewRes,SubRes,_,_,_)} <- +.lock, prt("Accepting Responsibility ", res), +assignment(Assignee,Res,manager), +!informAssignment(Assignee,Res)[perform], +!add([NewRes])[perform], -.lock;

//Decide if to accept responsibility
+!incomingRes(_, [])[perform] : {True} <- +.lock, print("Processed all responsibilities"), -.lock;
+!incomingRes(Assignee, [Res|T])[perform] : {B capacity(Res), B res(Res,Sub,_,_,_)} <- +.lock, prt("Chose To Accept ", Res), +!addAcceptedRes(Assignee, Res)[perform], +!incomingRes(Assignee, T)[perform], +!incomingRes(Assignee, Sub)[perform], -.lock;
+!incomingRes(Assignee, [Res|T])[perform] : {~B capacity(Res)} <- +.lock, prt("Chose To Not Accept ", Res), +!incomingRes(Assignee, T)[perform], -.lock; //Should send message back

//Check if res is fulfilled, remove if true and report back
+!checkIfFulfilled(Res)[perform] : {B finished(Res), B res(Res,_,_,_,oneshot)} <- +!rem([Res])[perform], reportBack(Res), -finished(Res);
+!checkIfFulfilled(Res)[perform] : {B finished(Res), B res(Res,_,_,_,repeat)} <- +!reportBack(Res)[perform], -finished(Res);
+!checkIfFulfilled(Res)[perform] : {B failed(Res), B res(Res,_,_,[],_)} <- +!rem([Res])[perform], +!reportBack(Res)[perform];
+!checkIfFulfilled(Res)[perform] : {B failed(Res), B res(Res,_,_,FailRes,_)} <- +!rem([Res])[perform], reportBack(Res), +!incomingRes(FailRes)[perform];
+!checkIfFulfilled(Res)[perform] : {True} <- prt("Worked on ", Res);

//Action For Res
+!doActionForRes(Res)[perform] :  {B failed(Res)} <- prt("Failed Res ", Res);
//Do all actions in a task before moving on to next res
+!doActionForRes(Res)[perform] : {B doAll, B res(Res,_,Name,_,_), B task(Name,[],_), ~B doneActions} <- prt("No actions for task ", Name), +doneActions;
+!doActionForRes(Res)[perform] : {B doAll, B finished(Action,true), B workingActions(Actions), ~B doneActions} <- prt("Finished Action ", Action), -finished(Action,true), -haveAction(Action), -workingActions(Actions), appendList([Action], Actions, Done), +workingActions(Done);
+!doActionForRes(Res)[perform] : {B doAll, B haveAction(none), ~B doneActions} <- prt("No more actions"), +doneActions;
+!doActionForRes(Res)[perform] : {B doAll, B haveAction(Action), ~B doneActions} <- prt("Doing Action ", Action), do(Action,Finished), -finished(Action,Finished), +finished(Action,Finished), prt("Finished Status ", Action, " ", Finished);
+!doActionForRes(Res)[perform] : {B doAll, B res(Res,_,Name,_,_), B task(Name,Actions,_), B workingActions(Done), ~B doneActions} <- prt("Getting next action in ", Actions), getNextInList(Actions, Done, Action), +haveAction(Action);

//+!doActionForRes(Res)[perform] : {B doAll, B res(Res,_,Name,_), B task(Name,[],_), ~B doneActions(true)} <- print("No actions to do"), +doneActions(true);
//+!doActionForRes(Res)[perform] : {B doAll, B res(Res,_,Name,_), B task(Name,Actions,_), B workingActions(Done), ~B doneActions(true)} <- +.lock, prt("Task ", Name, " with Actions", Actions), getNextInList(Actions,Done,Task), do(Task), appendList([Task],Done,NDone), -workingActions(Done), +workingActions(NDone), doneAll(Actions,NDone,Finished), prt("Done Task ", Task, " Completed ", NDone), -doneActions(false), +doneActions(Finished), -.lock;

+!doActionForRes(Res)[perform] : {B doAll, B res(Res,_,Name,_,_), B task(Name,_,[]), ~B doneStates} <- prt("No states for task ", Name), +doneStates;
+!doActionForRes(Res)[perform] : {B doAll, B finished(State,true), B workingStates(States), ~B doneStates} <- prt("Finished State ", State), -finished(State,true), -haveState(State), -workingStates(States), appendList([State], States, Done), +workingStates(Done);
+!doActionForRes(Res)[perform] : {B doAll, B haveState(none), ~B doneStates} <- prt("No more states"), +doneStates;
+!doActionForRes(Res)[perform] : {B doAll, B haveState(State), ~B doneStates} <- prt("Doing State ", State), do(State,Finished), -finished(State,Finished), +finished(State,Finished), prt("Finished Status ", State, " ", Finished);
+!doActionForRes(Res)[perform] : {B doAll, B res(Res,_,Name,_,_), B task(Name,_,States), B workingStates(Done), ~B doneStates} <- prt("Getting next state in ", States), getNextInList(States, Done, State), +haveState(State);

//+!doActionForRes(Res)[perform] : {B doAll, B res(Res,_,Name,_), B task(Name,_,[]), ~B doneStates(true)} <- print("No states to do"), +doneStates(true);
//+!doActionForRes(Res)[perform] : {B doAll, B res(Res,_,Name,_), B task(Name,_,States), B workingStates(Done), ~B doneStates(true)} <- +.lock, prt("Task" , Name, " with States", States), getNextInList(States,Done,State), check(State), appendList([State],Done,NDone),  -workingStates(Done), +workingStates(NDone), doneAll(States,NDone,Finished), prt("Done State ", State, " Completed ", NDone),-doneStates(false), +doneStates(Finished), -.lock;

+!doActionForRes(Res)[perform] : {~B failed(Res), B doAll, B doneActions, B doneStates, B workingRes(List)} <- +.lock, +finished(Res), appendList([Res],List,NList), -workingRes(List), +workingRes(NList), prt("Completed Res are ", NList), -doneActions, -doneStates, -.lock;

+!doActionForRes(Res)[perform] : {True} <- prt("Could not find res ", res, " likely all res completed"); 
//Do one random action in a task before moving on

//Do one task in order before moving on

//Cleanup before repeating res loop
+!doCleanUp[perform] : {B workingRes(Res), B workingActions(Tasks), B workingStates(States)} <- print("Cleaning up"), -workingRes(Res), -workingActions(Tasks), -workingStates(States), +workingRes([]), +workingActions([]), +workingStates([]), -cleanup(true);

//Responsibility Loop
+!test[perform] : {B cleanup(true)} <- +.lock, print("Do clean up"), +!doCleanUp[perform], -.lock, +!test[perform];
+!test[perform] : {B currentRes([])} <- print("No Responsibilities"), +!test[perform];
+!test[perform] : {~B ready} <- print("Not Ready Processing"), +!test[perform];
+!test[perform] : {B currentRes(ResList), B workingRes(Comp), B ready} <- +.lock, getCared(ResList, Res, Comp), prt("Responsibilities ",ResList," doing ", Res), +!doActionForRes(Res)[perform], +!checkIfFulfilled(Res)[perform], doneAll(ResList,Comp,Out), -cleanup(false), +cleanup(Out), -.lock, +!test[perform]; 
+!test[perform] : {True} <- print("Failed"), printstate;


