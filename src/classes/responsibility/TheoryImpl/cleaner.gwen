GWENDOLEN

:name: cleaner

:Initial Beliefs:

res(reportHuman, [], sendToHuman, [], oneshot)

res(cleanA, [], cleanroomA, [], repeat)
res(cleanB, [], cleanroomB, [], repeat)
res(cleanC, [], cleanroomC, [], repeat)
res(cleanD, [], cleanroomD, [], repeat)
res(cleanE, [], cleanroomE, [], repeat)
res(cleanF, [], cleanroomF, [], repeat)
res(cleanG, [], cleanroomG, [], repeat)
res(cleanH, [], cleanroomH, [], repeat)
res(cleanI, [], cleanroomI, [], repeat)
res(cleanJ, [], cleanroomJ, [], repeat)

res(observeA, [], observeA, [], repeat)
res(observeB, [], observeB, [], repeat)
res(observeC, [], observeC, [], repeat)
res(observeD, [], observeD, [], repeat)
res(observeE, [], observeE, [], repeat)
res(observeF, [], observeF, [], repeat)
res(observeG, [], observeG, [], repeat)
res(observeH, [], observeH, [], repeat)
res(observeI, [], observeI, [], repeat)
res(observeJ, [], observeJ, [], repeat)

res(cleanBadDirtA, [], cleanroomA, [], repeat)
res(cleanBadDirtB, [], cleanroomB, [], repeat)
res(cleanBadDirtC, [], cleanroomC, [], repeat)
res(cleanBadDirtD, [], cleanroomD, [], repeat)
res(cleanBadDirtE, [], cleanroomE, [], repeat)
res(cleanBadDirtF, [], cleanroomF, [], repeat)
res(cleanBadDirtG, [], cleanroomG, [], repeat)
res(cleanBadDirtH, [], cleanroomH, [], repeat)
res(cleanBadDirtI, [], cleanroomI, [], repeat)
res(cleanBadDirtJ, [], cleanroomJ, [], repeat)

res(janitorial,[safety,cleanliness],none,[],repeat)
res(safety,[cleanBadDirtA,cleanBadDirtB,cleanBadDirtC,cleanBadDirtD,cleanBadDirtE,cleanBadDirtF,cleanBadDirtG,cleanBadDirtH,cleanBadDirtI,cleanBadDirtJ],checkDirtLevel,[reportHuman],repeat)
res(cleanliness,[observe,clean],none,[],repeat)
res(observe,[observeA,observeB,observeC,observeD,observeE,observeF,observeG,observeH,observeI,observeJ],none,[],repeat)
res(clean,[cleanA,cleanB,cleanC,cleanD,cleanE,cleanF,cleanG,cleanH,cleanI,cleanJ],none,[],repeat)


responsibilities([])

:Reasoning Rules:


:Initial Goals:
go[perform]


:Plans: 

+!go[perform] : {True} <- +!processRes(initial,[janitorial])[perform];

+!action(Res,A)[perform] : {True} <- prt("Doing ", A);

+!addRes(Res)[perform] : {B responsibilities(L)} <- +.lock, -responsibilities(L), appendList([Res],L,Out), +responsibilities(Out), -.lock;
+!remRes(Res)[perform] : {B responsibilities(L)} <- +.lock, -responsibilities(L), deleteItem(Res,L,Out), +responsibilities(Out), -.lock;

//Add new responsibility
+!incomingRes(Assignee,[Res])[perform] : {True} <- prt("Accepting ", Res), +.lock, +assignment(Assignee,Res), +!addRes(Res)[perform], +!reportOutcome(yes,Assignee,Res)[perform], -.lock;

+!processRes(Assignee,[])[perform] : {B responsibilities(H)} <- prt("Processed Res have ", H);
+!processRes(Assignee,[Res])[perform] : {B res(Res,[],_,_,_)} <- +!incomingRes(Assignee,[Res])[perform];
+!processRes(Assignee,[Res|T])[perform] : {B res(Res,SubRes,_,_,_)} <- +!incomingRes(Assignee,[Res])[perform], +!processRes(Assignee,T)[perform], +!processRes(Assignee,SubRes)[perform];

//Messages to send back
+!reportOutcome(_, [], Res)[perform] : {True} <- prt("Reported accepted to all");
+!reportOutcome(yes, [Assignee|T], Res)[perform] : {True} <- .send(Assignee, :tell, accepted(Res, cleaner)), +!reportOutcome(yes,T,Res)[perform];
+!reportOutcome(yes, Assignee, Res)[perform] : {True} <- .send(Assignee, :tell, accepted(Res, cleaner));
+!reportOutcome(no, [Assignee|T], Res)[perform] : {True} <- .send(Assignee, :tell, rejected(Res, cleaner)), +!reportOutcome(yes,T,Res)[perform];
+!reportOutcome(no, Assignee, Res)[perform] : {True} <- .send(Assignee, :tell, rejected(Res, cleaner));

