GWENDOLEN

:name: manager

:Initial Beliefs:
//Cleaning Responsibility Tree
node(clean,[patrol,no_dirt])
node(patrol,[patrol_1,patrol_2,patrol_3,patrol_4,patrol_5])
node(no_dirt,[no_dirt_1,no_dirt_2,no_dirt_3,no_dirt_4,no_dirt_5])

//Current Responsibilities
currentRes([clean])
currentItem(0)
activeRes([])
completedRes([])

:Reasoning Rules:
bNo_dirt :- bNo_dirt_1,bNo_dirt_2,bNo_dirt_3,bNo_dirt_4,bNo_dirt_5
withinLimit(Res, X) :- length(Res, Y), Y > X
isActive(RList, Res) :- member(RList, Res)

:Initial Goals:
doRes

:Plans: 

//Clean Responsibility
+!resolveRes(clean)[perform] {~B isActive(RList, Res), B node(clean, X), B currentRes(Z), B activeRes(Res)} <- -currentRes(Z), remove(clean, Z), append(X, Z, N), +currentRez(N);

//Patrol Responsibility
+!resolveRes(patrol)[perform] {B node(patrol, X), B currentRes(Z)} <- -currentRes(Z), remove(patrol, Z), append(X, Z, N), +currentRez(N);

//Dirt Responsibility
+!resolveRes(no_dirt)[perform] {B bNo_dirt, B activeRes(Res)} <- remove(no_dirt, Res, NRes), -activeRes(Res), +activeRes(NRes);


//Traverse Responsibilities, iterate through list
+!doRes[achieve]{B currentRes(Res), B currentItem(X), B withinLimit(Res,X)} <- getCurrentItem(Res, X, H), resolveRes(H)[perform], -currentItem(X), add(X,1,Y), +currentItem(Y);
+!doRes[achieve]{B currentRes(Res), B currentItem(X), ~B withinLimit(Res,X)} <- -currentItem(X), +currentItem(0);
