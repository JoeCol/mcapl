GWENDOLEN

:name: manager

:Initial Beliefs:
//Cleaning Responsibility Tree
node(clean,[patrol,no_dirt])
node(patrol,[patrol_1,patrol_2,patrol_3,patrol_4,patrol_5])
node(no_dirt,[dirt_1,dirt_2,dirt_3,dirt_4,dirt_5])

//Current Responsibilities
currentRes([clean])

:Reasoning Rules:
dirt :- dirt_1;
dirt :- dirt_2;
dirt :- dirt_3;
dirt :- dirt_4;
dirt :- dirt_5;

:Initial Goals:
doRes[achieve]

:Plans: 

//Clean Responsibility
+!resolveRes(clean)[perform] : {B currentRes(Z), B node(clean, X)} <- +.lock, -currentRes(Z), appendList(Z, X, N), +currentRes(N), -.lock;

//Patrol Responsibility
+!resolveRes(patrol)[perform] : {B currentRes(Z), B node(patrol, X)} <- +.lock, -currentRes(Z), appendList(Z, X, N), +currentRes(N), -.lock;

//at location
+!resolveRes(patrol_1)[perform] : {B at(X,Y)} <- go_to_zone(1), *zone(1), observeDirt, *observed, removeObserved;
+!resolveRes(patrol_2)[perform] : {B at(X,Y)} <- go_to_zone(2), *zone(2), observeDirt, *observed, removeObserved;
+!resolveRes(patrol_3)[perform] : {B at(X,Y)} <- go_to_zone(3), *zone(3), observeDirt, *observed, removeObserved;
+!resolveRes(patrol_4)[perform] : {B at(X,Y)} <- go_to_zone(4), *zone(4), observeDirt, *observed, removeObserved;
+!resolveRes(patrol_5)[perform] : {B at(X,Y)} <- go_to_zone(5), *zone(5), observeDirt, *observed, removeObserved;

//Dirt Responsibility
+!resolveRes(no_dirt)[perform] : {~B dirt, B currentRes(Z), B node(no_dirt,X)} <- print(remove), -currentRes(Z), removeList(Z, X, N), +currentRes(N);
+!resolveRes(no_dirt)[perform] : {B dirt, B currentRes(Z), B node(no_dirt,X)} <- print(adding), -currentRes(Z), appendList(Z, X, N), +currentRes(N);

//Specific dirt responsibilities - should remove from active responsibilities when done
+!resolveRes(dirt_1)[perform] : {B dirt_1} <- go_to_zone(1), *zone(1), do_clean(1), *finished, finishClean, print(done1);
+!resolveRes(dirt_1)[perform] : {~B dirt_1} <- print(nodirtinzone1);

+!resolveRes(dirt_2)[perform] : {B dirt_2} <- go_to_zone(2), *zone(2), do_clean(2), *finished, finishClean, print(done2);
+!resolveRes(dirt_2)[perform] : {~B dirt_2} <- print(nodirtinzone2);

+!resolveRes(dirt_3)[perform] : {B dirt_3} <- go_to_zone(3), *zone(3), do_clean(3), *finished, finishClean, print(done3);
+!resolveRes(dirt_3)[perform] : {~B dirt_3} <- print(nodirtinzone3);

+!resolveRes(dirt_4)[perform] : {B dirt_4} <- go_to_zone(4), *zone(4), do_clean(4), *finished, finishClean, print(done4);
+!resolveRes(dirt_4)[perform] : {~B dirt_4} <- print(nodirtinzone4);

+!resolveRes(dirt_5)[perform] : {B dirt_5} <- go_to_zone(5), *zone(5), do_clean(5), *finished, finishClean, print(done5);
+!resolveRes(dirt_5)[perform] : {~B dirt_5} <- print(nodirtinzone5);

//Iterate list, get updated belief
+!iterateRes[perform] : {B currentRes(Res)} <- -currentRes(Res), iterateRes(Res,X), +currentRes(X);
//Traverse Responsibilities, iterate through list
+!doRes[achieve] : {B currentRes([H|T]), B currentRes(Res)} <- print(H), +!resolveRes(H)[perform], +!iterateRes[perform]; 
