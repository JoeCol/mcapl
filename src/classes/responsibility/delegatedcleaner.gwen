GWENDOLEN

:name: manager

:Initial Beliefs:
//Cleaning responsibility actions
res(clean(X), do, null)
res(hoover(X), do, null)
res(observeDirt, observe, null)

//Safety responsibility actions
res(safety, delegate, manager)
res(observeSafe, observe, null)

//Tree nodes for responsibilities
resTree(cleaning, [clean, hoover, observeDirt])
resTree(clean, [])
resTree(hoover, [])
resTree(observeDirt, [])

resTree(safety, [observeSafe])
resTree(observeSafe, [])


cleanlist([])
:Reasoning Rules:

:Initial Goals:
resolveRes([safety])[perform]

:Plans: 

//Received a delegated responsibility
+.received(:tell, X): {True} <- +!resolveRes(X)[perform];

//Observe Dirt
+!observe[achieve] : {B observed(X)} <- +!resolveRes([clean(X)])[perform];
+!observe[achieve] : {B readyToObserve} <- observeDirt;
+!observe[achieve] : {True} <- goToRandomZone;

//Delegate
+!delegate(X,Ags)[perform] : {True} <- .send(Ags,:tell,X);

//Clean and hoover
+!clean
+!clean [perform] : {B cleaned(Z)} <- print("Finished Cleaning");
+!clean [perform] : {B cleanlist([Z|T]), B zone(Z), B at(X,Y)} <- print("Cleaning"), do_clean(Z, X, Y), +!clean [perform];
+!clean [perform] : {~B zone(Z), B at(X,Y)} <- print("Going to zone"), go_to_zone(Z, X, Y), +!clean [perform];

//Responsilibilty Actions
+!doRes(H)[perform] : {B res(H, delegate, Ags)} <- +!delegate(H, Ags)[perform];
+!doRes(H)[perform] : {B res(H, observe, null)} <- +!observe[achieve];
+!doRes(clean(X))[perform] : {B res(clean(X), do, B cleanlist(Y)} <- +.lock, -cleanlist(Y), append(X,Y,Z), +cleanlist(Z), +!clean[perform], -.lock;
+!doRes(hoover(X))[perform] : {B res(hoover(X), do, null)} <- +!clean[perform];

//Resolve responsibility Responsibility
+!resolveRes([H|T])[perform] : {B resTree(H,[])} <- print(H), +!doRes(H)[perform], +!resolveRes(T)[perform];
+!resolveRes([H|T])[perform] : {B resTree(H, N)} <- print(H), append(N,T,Z), +!resolveRes(Z)[perform];
+!resolveRes(H)[perform] : {True} <- print(H), print("Last Item");
+!resolveRes([])[perform] : {True} <- print("Nothing");