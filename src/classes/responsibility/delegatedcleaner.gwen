GWENDOLEN

:name: manager

:Initial Beliefs:
//Cleaning responsibility actions
res(clean(X), do, null)
res(hoover(X), do, null)
res(observeDirt, observe, null)

//Safety responsibility actions
res(observeSafe, observeSafe, null)

//Tree nodes for responsibilities
resTree(cleaning, [observeDirt])
resTree(clean(X), [])
resTree(hoover(X), [])
resTree(observeDirt, [])

resTree(safety, [observeSafe])
resTree(observeSafe, [])


//Start
todo([safety, clean(1), clean(1), clean(5)])
:Reasoning Rules:

:Initial Goals:
resolveRes[perform]

:Plans: 

//Clean and hoover
+!clean(Z)[perform] : {B cleaned(Z), B cleaning} <- -cleaning, finishCleaning(Z), print("Finished Cleaning");
+!clean(Z)[perform] : {B zone(Z), B at(X,Y), B cleaning} <- print("Cleaning"), do_clean(Z, X, Y), +!clean(Z)[perform];
+!clean(Z)[perform] : {B at(X,Y)} <- print("Going to zone"), print(Z), go_to_zone(Z, X, Y), +cleaning, +!clean(Z)[perform];

//Received a delegated responsibility
+.received(:tell, X): {True} <- +!addRes([X])[perform];

//Delegate
+!delegate(X,Ags)[perform] : {True} <- .send(Ags,:tell,X);

//Responsibilty Actions
+!doRes(H)[perform] : {B res(H, delegate, Ags)} <- +!delegate(H, Ags)[perform];
+!doRes(H)[perform] : {B res(H, observeDirt, null)} <- +!observeDirt[perform];
+!doRes(H)[perform] : {B res(H, observeSafe, null)} <- +!observeSafe[perform];
+!doRes(H)[perform] : {B res(clean(X), do, null)} <- print(X), +!clean(X)[perform];

//Resolve responsibility Responsibility
+!resolveRes[perform] : {B todo([H|T]), B resTree(H, [])} <- +.lock, +!remRes(H)[perform], +!doRes(H)[perform], +!resolveRes[perform], -.lock;
+!resolveRes[perform] : {B todo([H|T]), B resTree(H, N)} <- +.lock, +!remRes(H)[perform], +!addRes(N)[perform], +!resolveRes[perform], -.lock;
+!resolveRes[perform] : {B todo([])} <- print("Nothing");
+!resolveRes[perform] : {B todo(Z)} <- print("Broken on "), print(Z);

//Responsibility List Management
+!addRes(X)[perform] : {B todo(Z)} <- +.lock, -todo(Z), print(Z), print("Adding"), print(X), append(X,Z,Y), +todo(Y), -.lock;
+!remRes(X)[perform] : {B todo(Z)} <- +.lock, -todo(Z), print(Z), print("Removing"), print(X), delete(X,Z,Y), +todo(Y), -.lock;

//Observe Dirt
+!observeDirt[perform] : {B goZone(Z), B zone(Z), B dirtInZone(1)} <- -goZone(Z), +!addRes([observeDirt])[perform], +!addRes([clean(Z)])[perform];
+!observeDirt[perform] : {B goZone(Z), B zone(Z), B dirtInZone(0)} <- -goZone(Z), +!addRes([observeDirt])[perform];
+!observeDirt[perform] : {B goZone(Z), B at(X,Y)} <- go_to_zone(Z, X, Y), +!addRes([observeDirt])[perform];
+!observeDirt[perform] : {B at(X,Y)} <- getRandomZone(Z), +goZone(Z), +!addRes([observeDirt])[perform];

//Observe Safe
+!observeSafe[perform] : {True} <- print("safe"), +!addRes([observeSafe])[perform];

