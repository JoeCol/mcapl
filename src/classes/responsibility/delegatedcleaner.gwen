GWENDOLEN

:name: manager

:Initial Beliefs:
//Cleaning Responsibility Tree
node(clean,[patrol,no_dirt])
node(patrol,[patrol_1,patrol_2,patrol_3,patrol_4,patrol_5])
node(no_dirt,[no_dirt_1,no_dirt_2,no_dirt_3,no_dirt_4,no_dirt_5])

//Current Responsibilities
currentRes([clean])
currentItem(0)
activeRes([])
completedRes([])

:Reasoning Rules:
bNo_dirt :- bNo_dirt_1,bNo_dirt_2,bNo_dirt_3,bNo_dirt_4,bNo_dirt_5;
endOfLimit(Res, X) :- length(Res, X);
isActive(RList, Res) :- member(RList, Res);

:Initial Goals:
doRes[achieve]

:Plans: 

//Clean Responsibility
+!resolveRes(clean)[perform] : {B currentRes(Z), ~B isActive(Z, clean), B node(clean, X)} <- -currentRes(Z), appendList(X, Z, N), +currentRes(N);
+!resolveRes(clean)[perform] : {B currentRes(Z), B isActive(Z, clean)} <- print("Still cleaning");

//Patrol Responsibility
+!resolveRes(patrol)[perform] : {B currentRes(Z), ~B isActive(Z, patrol), B node(patrol, X)} <- -currentRes(Z), appendList(X, Z, N), +currentRes(N);
+!resolveRes(patrol)[perform] : {B currentRes(Z), B isActive(Z, patrol)} <- print("Still patrolling");

//Dirt Responsibility
+!resolveRes(no_dirt)[perform] : {~B bNo_dirt, B currentRes(Z), ~B isActive(Z, no_dirt)} <- remove(no_dirt, Res, NRes), -activeRes(Res), +activeRes(NRes);
+!resolveRes(no_dirt)[perform] : {B bNo_dirt, B currentRes(Z), ~B isActive(Z, no_dirt)} <- remove(no_dirt, Res, NRes), -activeRes(Res), +activeRes(NRes);
+!resolveRes(no_dirt)[perform] : {B currentRes(Z), B isActive(Z, no_dirt)} <- print("Still No dirt");


//Traverse Responsibilities, iterate through list
+!doRes[achieve] : {B currentRes(Res), B currentItem(X), ~B endOfLimit(Res,X)} <- getItem(Res, X, H), print(Res), print(X), +!resolveRes(H)[perform], -currentItem(X), sum(X,1,Y), +currentItem(Y);
+!doRes[achieve] : {B currentRes(Res), B currentItem(X), B endOfLimit(Res,X)} <- -currentItem(X), +currentItem(0);
